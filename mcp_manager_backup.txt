
# ==========================================
# FILE: backend/mcp_manager.py
# ==========================================

import asyncio
import json
import os
import shutil
from typing import Dict, Any, List, Optional
import sys

class MCPManager:
    def __init__(self, config_path: str = "mcp_config.json"):
        self.config_path = config_path
        self.processes: Dict[str, asyncio.subprocess.Process] = {}
        self.config = self._load_config()
        self.tool_cache = {}

    def _load_config(self) -> Dict[str, Any]:
        if not os.path.exists(self.config_path):
            return {"servers": {}}
        try:
            with open(self.config_path, 'r') as f:
                return json.load(f)
        except:
            return {"servers": {}}

    def save_config(self):
        with open(self.config_path, 'w') as f:
            json.dump(self.config, f, indent=2)

    async def add_server(self, name: str, config: Dict):
        self.config["servers"][name] = config
        self.save_config()
        await self.start_server(name, config)

    async def toggle_server(self, name: str, enabled: bool):
        if name in self.config.get("servers", {}):
            self.config["servers"][name]["enabled"] = enabled
            self.save_config()
            
            if enabled:
                await self.start_server(name, self.config["servers"][name])
            else:
                await self.stop_server(name)

    async def remove_server(self, name: str):
        await self.stop_server(name)
        
        if "servers" in self.config and name in self.config["servers"]:
            del self.config["servers"][name]
            self.save_config()
            
        if name in self.tool_cache:
            del self.tool_cache[name]

    async def start_all(self):
        if "servers" not in self.config: self.config["servers"] = {}
        for name, cfg in self.config.get("servers", {}).items():
            if cfg.get("enabled", True):
                await self.start_server(name, cfg)

    async def start_server(self, name: str, config: Dict):
        if name in self.processes: return
        
        cmd = config["command"]
        args = config["args"]
        env = os.environ.copy()
        env.update(config.get("env", {}))
        
        print(f"[MCP] Launching {name}...")
        try:
            # Platform specific python command resolution
            if cmd == "python":
                if shutil.which("python3"): cmd = "python3"
                elif shutil.which("python"): cmd = "python"
                
            process = await asyncio.create_subprocess_exec(
                cmd, *args,
                stdin=asyncio.subprocess.PIPE,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
                env=env
            )
            self.processes[name] = process
            
            # Initial handshake/discovery
            await self._refresh_tools(name)
            
        except Exception as e:
            print(f"[MCP] Failed to start {name}: {e}")

    async def stop_server(self, name: str):
        if name in self.processes:
            try:
                self.processes[name].terminate()
                await self.processes[name].wait()
            except: pass
            del self.processes[name]
            # Clear cache when stopped so tools are not advertised
            if name in self.tool_cache:
                del self.tool_cache[name]

    async def stop_all(self):
        for name in list(self.processes.keys()):
            await self.stop_server(name)

    # --- Communication Layer ---

    async def _send_json_rpc(self, process, method: str, params: Any = None, id: int = 1):
        if not process.stdin: return None
        
        req = {"jsonrpc": "2.0", "method": method, "params": params or {}, "id": id}
        try:
            data = json.dumps(req).encode() + b"\n"
            process.stdin.write(data)
            await process.stdin.drain()
            
            # Read response (Assuming line-delimited JSON-RPC for this simple implementation)
            line = await process.stdout.readline()
            if not line: return None
            return json.loads(line.decode())
        except Exception as e:
            print(f"[MCP] RPC Error: {e}")
            return None

    async def _refresh_tools(self, server_name: str):
        proc = self.processes.get(server_name)
        if not proc: return
        
        resp = await self._send_json_rpc(proc, "tools/list")
        if resp and "result" in resp:
            tools = resp["result"].get("tools", [])
            self.tool_cache[server_name] = tools
            print(f"[MCP] {server_name} registered {len(tools)} tools.")

    async def get_all_tools_definitions(self) -> List[Dict]:
        """Convert MCP tool definitions to OpenAI format"""
        definitions = []
        for server, tools in self.tool_cache.items():
            for tool in tools:
                definitions.append({
                    "type": "function",
                    "function": {
                        "name": tool["name"],
                        "description": tool.get("description", ""),
                        "parameters": tool.get("inputSchema", {})
                    }
                })
        return definitions

    async def execute_tool(self, tool_name: str, args: Dict) -> str:
        # Find provider
        server_name = next((s for s, tools in self.tool_cache.items() if any(t['name'] == tool_name for t in tools)), None)
        if not server_name: return "Tool not found."
            
        proc = self.processes.get(server_name)
        if not proc: return "Server not active."
        
        resp = await self._send_json_rpc(proc, "tools/call", {"name": tool_name, "arguments": args})
        
        if resp and "result" in resp:
            # Handle MCP content list (text/image) -> Flatten to text for LLM
            content = resp["result"].get("content", [])
            text_content = [c["text"] for c in content if c.get("type") == "text"]
            return "\n".join(text_content)
        elif resp and "error" in resp:
             return f"Error: {resp['error'].get('message')}"
             
        return "Empty response."

    def list_servers_status(self):
        return [{
            "id": k, 
            "name": k, 
            "status": "running" if k in self.processes else "stopped",
            "tools": self.tool_cache.get(k, [])
        } for k in self.config.get("servers", {})]
